{
  "$schema": "http://json-schema.org/draft-06/schema",
  "type": "object",
  "properties": {
    "hazelcast": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "import": {
          "$ref": "#/definitions/Import"
        },
        "config-replacers": {
          "$ref": "#/definitions/ConfigReplacers"
        },
        "cluster-name": {
          "type": "string"
        },
        "license-key": {
          "type": "string"
        },
        "instance-name": {
          "type": "string"
        },
        "management-center": {
          "$ref": "#/definitions/ManagementCenter"
        },
        "properties": {
          "type": "object"
        },
        "wan-replication": {
          "$ref": "#/definitions/WanReplication"
        },
        "network": {
          "$ref": "#/TODO"
        },
        "partition-group": {
          "$ref": "#/definitions/PartitionGroup"
        },
        "executor-service": {
          "$ref": "#/definitions/ExecutorService"
        },
        "durable-executor-service": {
          "$ref": "#/definitions/DurableExecutorService"
        },
        "scheduled-executor-service": {
          "$ref": "#/definitions/ScheduledExecutorService"
        },
        "cardinality-estimator": {
          "$ref": "#/definitions/CardinalityEstimator"
        },
        "queue": {
          "$ref": "#/definitions/Queue"
        },
        "map": {
          "$ref": "#/definitions/Map"
        },
        "multimap": {
          "$ref": "#/definitions/Multimap"
        },
        "replicatedmap": {
          "$ref": "#/definitions/ReplicatedMap"
        },
        "cache": {
          "$ref": "#/definitions/Cache"
        },
        "list": {
          "$ref": "#/definitions/List"
        },
        "set": {
          "$ref": "#/definitions/Set"
        },
        "topic": {
          "$ref": "#/TODO"
        },
        "reliable-topic": {
          "$ref": "#/TODO"
        },
        "ringbuffer": {
          "$ref": "#/TODO"
        },
        "flake-id-generator": {
          "$ref": "#/TODO"
        },
        "listeners": {
          "$ref": "#/TODO"
        },
        "serialization": {
          "$ref": "#/TODO"
        },
        "native-memory": {
          "$ref": "#/definitions/NativeMemory"
        },
        "security": {
          "$ref": "#/definitions/Security"
        },
        "member-attributes": {
          "$ref": "#/TODO"
        },
        "split-brain-protection": {
          "$ref": "#/TODO"
        },
        "lite-member": {
          "$ref": "#/definitions/LiteMember"
        },
        "hot-restart-persistence": {
          "$ref": "#/TODO"
        },
        "user-code-deployment": {
          "$ref": "#/TODO"
        },
        "crdt-replication": {
          "$ref": "#/TODO"
        },
        "pn-counter": {
          "$ref": "#/TODO"
        },
        "advanced-network": {
          "$ref": "#/TODO"
        },
        "cp-subsystem": {
          "$ref": "#/definitions/CPSubsystem"
        },
        "metrics": {
          "$ref": "#/definitions/Metrics"
        }
      }
    }
  },
  "definitions": {
    "Import": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "ConfigReplacers": {
      "type": "object",
      "properties": {
        "fail-if-value-missing": {
          "type": "boolean",
          "default": false
        },
        "replacers": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "class-name": {
                "type": "string"
              },
              "properties": {
                "type": "object"
              }
            },
            "required": [
              "class-name"
            ]
          }
        }
      }
    },
    "ManagementCenter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "scripting-enabled": {
          "type": "boolean",
          "default": false
        },
        "trusted-interfaces": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "WanReplication": false,
    "PartitionGroup": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false
        },
        "group-type": {
          "enum": [
            "HOST_AWARE",
            "CUSTOM",
            "PER_MEMBER",
            "ZONE_AWARE",
            "SPI"
          ],
          "default": "PER_MEMBER"
        },
        "member-group": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ExecutorService": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "statistics-enabled": {
            "type": "boolean",
            "default": true
          },
          "pool-size": {
            "$ref": "#/definitions/executorServicePoolSize"
          },
          "queue-capacity": {
            "type": "integer",
            "minimum": 0,
            "default": 2147483647
          },
          "split-brain-protection-ref": {
            "type": "string"
          }
        }
      }
    },
    "DurableExecutorService": {
      "type": "object",
      "additionalProperties": {
        "pool-size": {
          "$ref": "#/definitions/executorServicePoolSize"
        },
        "durability": {
          "type": "integer",
          "minimum": 0,
          "default": 1
        },
        "capacity": {
          "type": "integer",
          "minimum": 1,
          "default": 100
        },
        "split-brain-protection-ref": {
          "type": "string"
        }
      }
    },
    "ScheduledExecutorService": {
      "type": "object",
      "additionalProperties": {
        "pool-size": {
          "$ref": "#/definitions/executorServicePoolSize"
        },
        "durability": {
          "type": "integer",
          "minimum": 0,
          "default": 1
        },
        "capacity": {
          "type": "integer",
          "minimum": 1,
          "default": 100
        },
        "capacity-policy": {
          "enum": [
            "PER_NODE",
            "PER_PARTITION"
          ]
        },
        "split-brain-protection-ref": {
          "type": "string"
        },
        "merge-policy": {
          "$ref": "#/definitions/MergePolicy"
        }
      }
    },
    "executorServicePoolSize": {
      "type": "integer",
      "minimum": 1,
      "default": 16
    },
    "MergePolicyClassName": {
      "enum": [
        "ExpirationTimeMergePolicy",
        "HyperLogLogMergePolicy",
        "HigherHitsMergePolicy",
        "PutIfAbsentMergePolicy",
        "DiscardMergePolicy",
        "LatestUpdateMergePolicy",
        "PassThroughMergePolicy",
        "LatestAccessMergePolicy"
      ],
      "default": "PutIfAbsentMergePolicy"
    },
    "MergePolicy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "batch-size": {
          "type": "integer",
          "minimum": 0,
          "default": 100
        },
        "class-name": {
          "$ref": "#/definitions/MergePolicyClassName"
        }
      }
    },
    "CardinalityEstimator": {
      "additionalProperties": {
      }
    },
    "InMemoryFormat": {
      "enum": [
        "BINARY",
        "OBJECT",
        "NATIVE"
      ],
      "default": "BINARY",
      "description": "Binary type that will be used for storing records. Possible values: BINARY (default): keys and values will be stored as binary data. OBJECT: values will be stored in their object forms. NATIVE: values will be stored in non-heap region of JVM (Hazelcast Enterprise only)"
    },
    "Eviction": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "eviction-policy": {
          "enum": [
            "LRU",
            "LFU",
            "NONE",
            "RANDOM"
          ],
          "default": "NONE"
        },
        "max-size-policy": {
          "enum": [
            "PER_NODE",
            "PER_PARTITION",
            "USED_HEAP_PERCENTAGE",
            "USED_HEAP_SIZE",
            "FREE_HEAP_PERCENTAGE",
            "FREE_HEAP_SIZE",
            "ENTRY_COUNT",
            "USED_NATIVE_MEMORY_SIZE",
            "USED_NATIVE_MEMORY_PERCENTAGE",
            "FREE_NATIVE_MEMORY_SIZE",
            "FREE_NATIVE_MEMORY_PERCENTAGE"
          ],
          "default": "PER_NODE"
        },
        "size": {
          "type": "integer",
          "minimum": 0,
          "default": 2147483647
        }
      }
    },
    "IndexConfig": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "enum": [
            "SORTED",
            "BITMAP",
            "HASH"
          ],
          "default": "SORTED"
        },
        "name": {
          "type": "string"
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1
        },
        "bitmap-index-options": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "unique-key": {
              "type": "string",
              "default": "__key"
            },
            "unique-key-transformation": {
              "enum": [
                "OBJECT",
                "LONG",
                "RAW"
              ],
              "default": "OBJECT",
              "description": "Defines an assortment of transformations which can be applied to unique-key values. OBJECT: Extracted unique key value is interpreted as an object value. Non-negative unique ID is assigned to every distinct object value. LONG: Extracted unique key value is interpreted as a whole integer value of byte, short, int or long type. The extracted value is upcasted to long (if necessary) and unique non-negative ID is assigned to every distinct value. RAW: Extracted unique key value is interpreted as a whole integer value of byte, short, int or long type. The extracted value is upcasted to long (if necessary) and the resulting value is used directly as an ID."
            }
          }
        }
      },
      "required": [
        "attributes"
      ]
    },
    "Map": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "in-memory-format": {
            "$ref": "#/definitions/InMemoryFormat"
          },
          "metadata-policy": {
            "enum": [
              "CREATE_ON_UPDATE",
              "OFF"
            ],
            "default": "OFF"
          },
          "statistics-enabled": {
            "type": "boolean",
            "default": true
          },
          "cache-deserialized-values": {
            "enum": [
              "INDEX_ONLY",
              "NEVER",
              "ALWAYS"
            ],
            "default": "INDEX_ONLY"
          },
          "backup-count": {
            "$ref": "#/definitions/BackupCount"
          },
          "async-backup-count": {
            "$ref": "#/definitions/AsyncBackupCount"
          },
          "time-to-live-seconds": {
            "description": "The maximum number of seconds for each entry to stay in the map.",
            "type": "integer",
            "minimum": 0,
            "default": 0
          },
          "max-idle-seconds": {
            "type": "integer",
            "minimum": 0,
            "default": 0
          },
          "eviction": {
            "$ref": "#/definitions/Eviction"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          },
          "read-backup-data": {
            "description": "Sets if read-backup-data (reading local backup entries) is enabled for this map.",
            "type": "boolean",
            "default": false
          },
          "hot-restart": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "description": "Sets whether hot restart is enabled on related data structure.",
                "type": "boolean",
                "default": false
              },
              "fsync": {
                "description": "Sets whether disk write should be followed by an fsync() system call.",
                "type": "boolean",
                "default": false
              }
            }
          },
          "event-journal": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "capacity": {
                "type": "integer",
                "minimum": 1,
                "default": 10000,
                "description": "The capacity is the total number of items that the event journal can hold at any moment. The actual number of items contained in the journal can be lower. NOTE: The capacity is shared equally between all partitions. This is done by assigning each partition {capacity / partitionCount} available slots in the event journal. Because of this, the effective total capacity may be somewhat lower and you must make sure that the configured capacity is at least greater than the partition count."
              },
              "time-to-live-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "Time to live is the time the event journal retains items before removing them from the journal. The events are removed on journal read and write actions, not while the journal is idle. Time to live can be disabled by setting timeToLiveSeconds to 0. This means that the events never expire but they can be overwritten when the capacity of the journal is exceeded."
              }
            }
          },
          "merkle-tree": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "depth": {
                "type": "integer",
                "minimum": 2,
                "maximum": 27,
                "default": 10
              }
            }
          },
          "map-store": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": true
              },
              "initial-mode": {
                "enum": [
                  "LAZY",
                  "EAGER"
                ],
                "default": "LAZY",
                "description": "LAZY: Default load mode where load is async; EAGER: load mode where load is blocked till all partitions are loaded."
              },
              "write-delay-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "The number of seconds to delay before writing (storing) the dirty records."
              },
              "write-batch-size": {
                "type": "integer",
                "minimum": 1,
                "default": 1,
                "description": "The number of operations to be included in each batch processing round."
              },
              "write-coalescing": {
                "type": "boolean",
                "default": true,
                "description": " Setting writeCoalescing is meaningful if you are using write-behind MapStore. When writeCoalescing is true, only the latest store operation on a key in the writeDelaySeconds time-window will be reflected to MapStore."
              },
              "class-name": {
                "type": "string",
                "description": "The name for the MapStore implementation class"
              },
              "factory-class-name": {
                "type": "string",
                "description": "The name for the MapStoreFactory implementation class"
              },
              "properties": {
                "type": "object",
                "default": {}
              }
            },
            "default": {
              "enabled": false
            }
          },
          "near-cache": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "time-to-live-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "The maximum number of seconds for each entry to stay in the Near Cache (time to live). Entries that are older than timeToLiveSeconds will automatically be evicted from the Near Cache."
              },
              "max-idle-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "The maximum number of seconds each entry can stay in the Near Cache as untouched (not-read). Entries that are not read (touched) more than maxIdleSeconds value will get removed from the Near Cache. Accepts any integer between 0 and Integer#MAX_VALUE. The value 0 means Integer#MAX_VALUE. The default is 0."
              },
              "invalidate-on-change": {
                "type": "boolean",
                "default": true,
                "description": "Sets if Near Cache entries are invalidated when the entries in the backing data structure are changed. When this setting is enabled, a Hazelcast instance with a Near Cache listens for cluster-wide changes on the entries of the backing data structure and invalidates its corresponding Near Cache entries. Changes done on the local Hazelcast instance always invalidate the Near Cache immediately."
              },
              "in-memory-format": {
                "$ref": "#/definitions/InMemoryFormat"
              },
              "cache-local-entries": {
                "type": "boolean",
                "default": false,
                "description": "Sets if local entries are also cached in the Near Cache. This is useful when the in-memory format of the Near Cache is different from the backing data structure. This setting has no meaning on Hazelcast clients, since they have no local entries."
              },
              "eviction": {
                "$ref": "#/definitions/Eviction"
              }
            }
          },
          "wan-replication-ref": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "merge-policy-class-name": {
                  "$ref": "#/definitions/MergePolicyClassName"
                },
                "republishing-enabled": {
                  "type": "boolean",
                  "default": true,
                  "description": "Sets if incoming WAN events to this member should be republished (forwarded) to this WAN replication reference."
                },
                "filters": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of class names implementing the CacheWanEventFilter or MapWanEventFilter for filtering outbound WAN replication events. NOTE: EE only"
                }
              }
            }
          },
          "indexes": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/IndexConfig"
            }
          },
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "extractor-class-name": {
                  "type": "string",
                  "description": "Fully qualified class name of the extractor used to extract the value of the attribute."
                }
              },
              "required": [
                "extractor-class-name"
              ],
              "description": "Contains the configuration of a custom attribute that will be extracted from a Map's entry using a given ValueExtractor."
            }
          },
          "entry-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EntryListener"
            },
            "description": "Adds listeners (listener classes) for the map entries using the \"entry-listener\" sub-elements"
          },
          "partition-lost-listeners": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "query-caches": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "include-value": {
                  "type": "boolean",
                  "default": true,
                  "description": "Enables value caching."
                },
                "predicate": {
                  "type": "object",
                  "additionalProperties": false,
                  "properties": {
                    "class-name": {
                      "type": "string"
                    }
                  },
                  "description": "Predicate to filter events which will be applied to the query cache."
                },
                "entry-listeners": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/EntryListener"
                  }
                },
                "in-memory-format": {
                  "$ref": "#/definitions/InMemoryFormat"
                },
                "populate": {
                  "type": "boolean",
                  "default": true,
                  "description": "Flag to enable/disable initial population of the QueryCache."
                },
                "coalesce": {
                  "type": "boolean",
                  "default": false
                },
                "delay-seconds": {
                  "type": "integer",
                  "minimum": 0,
                  "default": 0,
                  "description": "Minimum time in seconds that an event waits in the member's buffer."
                },
                "batch-size": {
                  "type": "integer",
                  "minimum": 1,
                  "default": 1,
                  "description": "The batch size which will be used to determine number of events to be sent in a batch to QueryCache."
                },
                "buffer-size": {
                  "type": "integer",
                  "minimum": 1,
                  "default": 16,
                  "description": "Maximum number of events which can be stored in a buffer of partition."
                },
                "eviction": {
                  "$ref": "#/definitions/Eviction"
                },
                "indexes": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/IndexConfig"
                  }
                }
              }
            }
          }
        }
      }
    },
    "Set": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "backup-count": {
            "$ref": "#/definitions/BackupCount"
          },
          "async-backup-count": {
            "$ref": "#/definitions/AsyncBackupCount"
          },
          "max-size": {
            "type": "integer",
            "minimum": 0,
            "description": "Maximum size of the set (item count). Its default value is 0, meaning Integer.MAX_VALUE."
          },
          "item-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/ItemListener"
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "EntryListener": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "class-name": {
          "type": "string"
        },
        "include-value": {
          "type": "boolean",
          "default": false,
          "description": "True if you want the entry event to contain the item values."
        },
        "local": {
          "type": "boolean",
          "default": false,
          "description": "True if you want to listen to the entries on the local member."
        }
      },
      "required": [
        "class-name"
      ]
    },
    "Queue": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "statistics-enabled": {
            "type": "boolean",
            "default": true,
            "description": "When you enable it, you can retrieve queue statistics."
          },
          "max-size": {
            "type": "integer",
            "minimum": 0,
            "description": "Maximum size of the queue. When a JVM's local queue size reaches the maximum, all put/offer operations will be blocked until the queue size of the JVM goes below this maximum. Its default value is 0, meaning Integer.MAX_VALUE"
          },
          "backup-count": {
            "$ref": "#/definitions/BackupCount"
          },
          "async-backup-count": {
            "$ref": "#/definitions/AsyncBackupCount"
          },
          "empty-queue-ttl": {
            "type": "integer",
            "default": -1,
            "description": "Used to purge unused or empty queues. If you define a value (time in seconds) for this element, then your queue will be destroyed if it stays empty or unused for that time."
          },
          "item-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/ItemListener"
            }
          },
          "queue-store": {
            "type": "object",
            "additionalProperties": false,
            "description": "Includes configuration elements and attributes for your queue store implementation. When you want to load/store the distributed queue items from/to a persistent datastore, first implement Hazelcast's QueueStore interface and then configure it using this element",
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": true
              },
              "class-name": {
                "description": "The fully qualified name of the QueueStore implementation you want to use",
                "type": "string"
              },
              "factory-class-name": {
                "description": "The fully qualified name of the QueueStoreFactory which will be created by Hazelcast to instantiate QueueStores.",
                "type": "string"
              },
              "properties": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "binary": {
                    "type": "boolean",
                    "default": false,
                    "description": "If you do not reach the queue store from an external application, you might prefer to insert the items in binary form. To do so, set this property to true and skip the deserialization step, which is a performance optimization."
                  },
                  "memory-limit": {
                    "type": "integer",
                    "default": 1000,
                    "description": "Number of items after which Hazelcast will store items only to datastore. For example, if the memory limit is 1000, then the 1001st item will be put only to datastore. This feature is useful when you want to avoid out-of-memory conditions. If you want to always use memory, you can set it to Integer.MAX_VALUE."
                  },
                  "bulk-load": {
                    "type": "integer",
                    "default": 250,
                    "description": "Size of the bulks loaded from QueueStore when the queue is initialized."
                  }
                }
              }
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "ItemListener": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "include-value": {
          "type": "boolean",
          "default": true,
          "description": "Set to true if you want the item event to contain the item values."
        },
        "class-name": {
          "type": "string"
        }
      },
      "required": [
        "class-name"
      ]
    },
    "Multimap": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "backup-count": {
            "$ref": "#/definitions/BackupCount"
          },
          "async-backup-count": {
            "$ref": "#/definitions/AsyncBackupCount"
          },
          "value-collection-type": {
            "enum": [
              "SET",
              "LIST"
            ]
          },
          "binary": {
            "type": "boolean",
            "default": true,
            "description": "The in-memory format being used for representing the multimap. If it is false, the OBJECT in-memory format will be used."
          },
          "entry-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EntryListener"
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "ReplicatedMap": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "in-memory-format": {
            "$ref": "#/definitions/InMemoryFormat",
            "default": "OBJECT"
          },
          "async-fillup": {
            "type": "boolean",
            "default": true,
            "description": "Specifies whether the replicated map is available for reads before the initial replication is completed. If false, no Exception will be thrown when the replicated map is not yet ready, but call is blocked until the initial replication is completed."
          },
          "statistics-enabled": {
            "type": "boolean",
            "default": true,
            "description": "When you enable it, you can retrieve replicated map entry statistics such as creation time, expiration time, number of hits, key, value, etc."
          },
          "entry-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EntryListener"
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "Cache": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "key-type": {
            "$ref": "#/definitions/ClassNameObj"
          },
          "value-type": {
            "$ref": "#/definitions/ClassNameObj"
          },
          "statistics-enabled": {
            "type": "boolean",
            "default": false,
            "description": "When you enable it, you can retrieve cache entry statistics such as creation time, expiration time, number of hits, key, value, etc."
          },
          "management-enabled": {
            "type": "boolean",
            "default": false,
            "description": "If set to true, JMX beans are enabled and collected statistics are provided. It doesn't automatically enable statistics collection."
          },
          "read-through": {
            "type": "boolean",
            "default": false,
            "description": "If set to true, enables read-through behavior of the cache to an underlying configured javax.cache.integration.CacheLoader which is also known as lazy-loading."
          },
          "write-through": {
            "type": "boolean",
            "default": false,
            "description": "If set to true, enables write-through behavior of the cache to an underlying configured javax.cache.integration.CacheWriter which passes any changed value to the external backend resource."
          },
          "cache-loader-factory": {
            "description": "Fully qualified class name of the javax.cache.configuration.Factory implementation providing a javax.cache.integration.CacheLoader instance to the cache.",
            "$ref": "#/definitions/ClassNameObj"
          },
          "cache-loader": {
            "type": "string",
            "description": "Name of the cache loader class."
          },
          "cache-writer-factory": {
            "$ref": "#/definitions/ClassNameObj",
            "description": "Fully qualified class name of the javax.cache.configuration.Factory implementation providing a javax.cache.integration.CacheWriter instance to the cache."
          },
          "cache-writer": {
            "type": "string",
            "description": "Name of the cache writer class."
          },
          "expiry-policy-factory": {
            "$ref": "#/definitions/ClassNameObj",
            "description": "Fully qualified class name of the javax.cache.configuration.Factory implementation providing a javax.cache.expiry.ExpiryPolicy instance to the cache."
          },
          "cache-entry-listeners": {
            "type": "object",
            "properties": {
              "cache-entry-listener": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "old-value-required": {
                    "type": "boolean",
                    "default": false,
                    "description": "If set to true, previously assigned values for the affected keys will be sent to the javax.cache.event.CacheEntryListener implementation. Setting this attribute to true creates additional traffic."
                  },
                  "synchronous": {
                    "type": "boolean",
                    "default": false,
                    "description": "If set to true, the javax.cache.event.CacheEntryListener implementation will be called in a synchronous manner."
                  },
                  "cache-entry-listener-factory": {
                    "$ref": "#/definitions/ClassNameObj",
                    "description": "Fully qualified class name of the javax.cache.configuration.Factory implementation providing a javax.cache.event.CacheEntryListener instance."
                  },
                  "cache-entry-event-filter-factory": {
                    "$ref": "#/definitions/ClassNameObj",
                    "description": "Fully qualified class name of the javax.cache.configuration.Factory implementation providing a javax.cache.event.CacheEntryEventFilter instance."
                  }
                }
              }
            },
            "description": "List of cache entry listeners."
          },
          "in-memory-format": {
            "$ref": "#/definitions/InMemoryFormat",
            "default": "BINARY"
          },
          "backup-count": {
            "$ref": "#/definitions/BackupCount"
          },
          "async-backup-count": {
            "$ref": "#/definitions/AsyncBackupCount"
          },
          "eviction": {
            "$ref": "#/definitions/Eviction"
          },
          "wan-replication-ref": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the WAN replication configuration"
              },
              "republishing-enabled": {
                "type": "boolean",
                "default": true,
                "description": "When enabled, an incoming event to a member is forwarded to target cluster of that member. "
              },
              "filters": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "Filters to intercept WAN replication events before they are placed to WAN event replication queues by providing a filtering API. Just implement Hazelcast's CacheWanEventFilter interface to create your filters."
              },
              "merge-policy-class-name": {
                "enum": [
                  "HigherHitsMergePolicy",
                  "PassThroughMergePolicy"
                ],
                "description": "Resolve conflicts that occurred when target cluster already has the replicated entry key."
              }
            }
          },
          "split-brain-protection-ref": {
            "type": "string",
            "description": "Adds the split brain protection for this cache. The value should be a \"split-brain-protection\"'s name."
          },
          "partition-lost-listeners": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Adds the partition lost listeners that you created by implementing Hazelcast's PartitionLostListener interface."
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          },
          "hot-restart": {
            "type": "object",
            "additionalProperties": false,
            "description": "Used to enable Hazelcast's Hot Restart Persistence feature for the cache. It is available only in Hazelcast Enterprise HD. Set its \"enabled\" to true to enable the feature. By default, it is disabled.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "fsync": {
                "type": "boolean",
                "default": false,
                "description": "Set as true if the writing to disk should be followed by an fsync() system call."
              }
            }
          },
          "event-journal": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "capacity": {
                "type": "integer",
                "minimum": 0,
                "default": 10000,
                "description": "The capacity of the event journal. The capacity is the total number of items that the event journal can hold at any moment. The actual number of items contained in the journal can be lower. The capacity is shared equally between all partitions. This is done by assigning each partition capacity / partitionCount available slots in the event journal. Because of this, the effective total capacity may be somewhat lower and you must take into account that the configured capacity is at least greater than the partition count."
              },
              "time-to-live-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "Sets the time to live in seconds. Time to live is the time the event journal retains items before removing them from the journal. The events are removed on journal read and write actions, not while the journal is idle. Time to live can be disabled by setting timeToLiveSeconds to 0. This means that the events never expire but they can be overwritten when the capacity of the journal is exceeed. Any integer between 0 and Integer.MAX_VALUE. 0 means infinite."
              }
            }
          },
          "disable-per-entry-invalidation-events": {
            "type": "boolean",
            "default": false,
            "description": "Disables invalidation events for each entry; but full-flush invalidation events are still enabled. Full-flush invalidation means the invalidation of events for all entries when clear is called."
          }
        }
      }
    },
    "ClassNameObj": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "class-name": {
          "type": "string",
          "description": "Fully qualified class name."
        }
      },
      "required": [
        "class-name"
      ]
    },
    "ClassNameWithProps": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "class-name": {
          "type": "string",
          "description": "Fully qualified class name."
        },
        "properties": {
          "type": "object"
        }
      },
      "required": [
        "class-name"
      ]
    },
    "Metrics": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "The master-switch for the metrics collection. If this is set to false no metrics collection is done, regardless of the other settings."
        },
        "management-center": {
          "type": "object",
          "description": "Defines the Hazelcast Management Center related metrics configuration.",
          "additionalProperties": false,
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": true,
              "description": "Controls whether the metrics collected are exposed to Hazelcast Management Center. Please note that the metrics are polled by the Hazelcast Management Center, hence the members need to buffer the collected metrics between two polls. The aim for this switch is to reduce memory consumption of the metrics system if the Hazelcast Management Center is not used."
            },
            "retention-seconds": {
              "type": "integer",
              "minimum": 1,
              "default": 5,
              "description": "Sets the number of seconds the metrics will be retained on the instance. More retention means more heap memory, but allows for longer client hiccups without losing a value (for example to restart the Management Center)."
            }
          }
        },
        "jmx": {
          "type": "object",
          "description": "Defines the JMX related metrics configuration.",
          "additionalProperties": false,
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": true,
              "description": "Controls whether the metrics collected are exposed to through JMX. It is enabled by default. In order to expose the metrics, the metrics system need to be enabled via the enabled master-switch attribute."
            }
          }
        },
        "collection-frequency-seconds": {
          "type": "integer",
          "minimum": 1,
          "default": 5,
          "description": "Sets the metrics collection frequency in seconds."
        }
      }
    },
    "LiteMember": {
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false
        }
      },
      "description": "When you want to use a Hazelcast member as a lite member, set this element's \"enabled\" attribute to true in that member's YAML configuration. Lite members do not store data, do not have partitions and are used mainly to execute tasks and register listeners."
    },
    "CPSubsystem": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cp-member-count": {
          "default": 0,
          "anyOf": [
            {
              "const": 0
            },
            {
              "type": "integer",
              "minimum": 3
            }
          ],
          "description": "Number of CP Members to initialize the CP Subsystem. The CP subsystem is enabled when a positive value is set. After the CP subsystem is initialized successfully, more CP members can be added at run-time and number of active CP members can go beyond the configured CP member count. Number of CP members can be smaller than total size of the Hazelcast cluster. For instance, you can run 5 CP members in a 20-member Hazelcast cluster. If set, must be greater than or equal to \"group-size\"."
        },
        "group-size": {
          "type": "integer",
          "minimum": 3,
          "maximum": 7,
          "not": {
            "multipleOf": 2
          },
          "description": "Number of CP members to run CP groups. If set, it must be an odd number between 3 and 7. Otherwise, \"cp-member-count\" is respected. If set, must be smaller than or equal to \"cp-member-count\"."
        },
        "session-time-to-live-seconds": {
          "type": "integer",
          "minimum": 1,
          "default": 300,
          "description": "Duration for a CP session to be kept alive after the last received heartbeat. The session will be closed if there is no new heartbeat this duration. Session TTL must be decided wisely. If a very low value is set, CP session of a Hazelcast instance can be closed prematurely if the instance temporarily loses connectivity to the CP subsystem because of a network partition or a GC pause. In such an occasion, all CP resources of this Hazelcast instance, such as FencedLock or ISemaphore, are released. On the other hand, if a very large value is set, CP resources can remain assigned to an actually crashed Hazelcast instance for too long and liveliness problems can occur. The CP subsystem offers an API, CPSessionManagementService, to deal with liveliness issues related to CP sessions. In order to prevent premature session expires, session TTL configuration can be set a relatively large value and CPSessionManagementService#forceCloseSession() can be manually called to close CP session of a crashed Hazelcast instance. Must be greater than \"session-heartbeat-interval-seconds\", and smaller than or equal to \"missing-cp-member-auto-removal-seconds\"."
        },
        "session-heartbeat-interval-seconds": {
          "type": "integer",
          "minimum": 1,
          "default": 5,
          "description": "Interval for the periodically-committed CP session heartbeats. A CP session is started on a CP group with the first session-based request of a Hazelcast instance. After that moment, heartbeats are periodically committed to the CP group. Must be smaller than \"session-time-to-live-seconds\"."
        },
        "missing-cp-member-auto-removal-seconds": {
          "type": "integer",
          "minimum": 0,
          "default": 14400,
          "description": "Duration to wait before automatically removing a missing CP member from the CP subsystem. When a CP member leaves the cluster, it is not automatically removed from the CP subsystem, since it could be still alive and left the cluster because of a network partition. On the other hand, if a missing CP member is actually crashed, it creates a danger for its CP groups, because it will be still part of majority calculations. This situation could lead to losing majority of CP groups if multiple CP members leave the cluster over time. With the default configuration, missing CP members will be automatically removed from the CP subsystem after 4 hours. This feature is very useful in terms of fault tolerance when CP member count is also configured to be larger than group size. In this case, a missing CP member will be safely replaced in its CP groups with other available CP members in the CP subsystem. This configuration also implies that no network partition is expected to be longer than the configured duration. Must be greater than or equal to \"session-time-to-live-seconds\". If a missing CP member comes back alive after it is automatically removed from the CP subsystem with this feature, that CP member must be terminated manually. The default is 4 hours."
        },
        "fail-on-indeterminate-operation-state": {
          "type": "boolean",
          "default": false,
          "description": "Offers a choice between at-least-once and at-most-once execution of the operations on top of the Raft consensus algorithm. It is disabled by default and offers at-least-once execution guarantee. If enabled, it switches to at-most-once execution guarantee. When you invoke an API method on a CP data structure proxy, it replicates an internal operation to the corresponding CP group. After this operation is committed to majority of this CP group by the Raft leader node, it sends a response for the public API call. If a failure causes loss of the response, then the calling side cannot determine if the operation is committed on the CP group or not. In this case, if this configuration is disabled, the operation is replicated again to the CP group, and hence could be committed multiple times. If it is enabled, the public API call fails with com.hazelcast.core.IndeterminateOperationStateException"
        },
        "persistence-enabled": {
          "type": "boolean",
          "default": false,
          "description": " Flag to denote whether or not CP Subsystem Persistence is enabled. If enabled, CP members persist their local CP data to stable storage and can recover from crashes."
        },
        "base-dir": {
          "type": "string",
          "default": "cp-data",
          "description": "Base directory to store all CP data when persistence-enabled is true. This directory can be shared between multiple CP members. Each CP member creates a unique directory for itself under the base directory. This is especially useful for cloud environments where CP members generally use a shared filesystem."
        },
        "data-load-timeout-seconds": {
          "type": "integer",
          "minimum": 1,
          "default": 120,
          "description": "Timeout duration for CP members to restore their data from disk. CP member fails its startup if it cannot complete its CP data restore rocess in the configured duration."
        },
        "raft-algorithm": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "leader-election-timeout-in-millis": {
              "type": "integer",
              "default": 2000,
              "minimum": 1,
              "description": "Leader election timeout in milliseconds. If a candidate cannot win majority of the votes in time, a new election round is initiated."
            },
            "leader-heartbeat-period-in-millis": {
              "type": "integer",
              "default": 5000,
              "minimum": 1,
              "description": "Period in milliseconds for a leader to send heartbeat messages to its followers."
            },
            "max-missed-leader-heartbeat-count": {
              "type": "integer",
              "default": 5,
              "minimum": 1,
              "description": "Maximum number of missed leader heartbeats to trigger a new leader election."
            },
            "append-request-max-entry-count": {
              "type": "integer",
              "default": 100,
              "minimum": 1,
              "description": "Maximum number of entries that can be sent in a single batch of append entries request."
            },
            "commit-index-advance-count-to-snapshot": {
              "type": "integer",
              "default": 10000,
              "minimum": 1,
              "description": "Number of new commits to initiate a new snapshot after the last snapshot."
            },
            "uncommitted-entry-count-to-reject-new-appends": {
              "type": "integer",
              "default": 100,
              "minimum": 1,
              "description": "Maximum number of uncommitted entries in the leader's Raft log before temporarily rejecting new requests of callers."
            },
            "append-request-backoff-timeout-in-millis": {
              "type": "integer",
              "minimum": 1,
              "default": 100,
              "description": "Timeout in milliseconds for append request backoff. After the leader sends an append request to a follower, it will not send a subsequent append request until the follower responds to the former request or this timeout occurs."
            }
          }
        },
        "semaphores": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "jdk-compatible": {
                "type": "boolean",
                "default": false,
                "description": " Enables / disables JDK compatibility of the CP ISemaphore. When it is JDK compatible, just as in the Semaphore#release() method, a permit can be released without acquiring it first, because acquired permits are not bound to threads. However, there is no auto-cleanup of acquired permits upon Hazelcast server / client failures. If a permit holder fails, its permits must be released manually. When JDK compatibility is disabled, a HazelcastInstance must acquire permits before releasing them and it cannot release a permit that it has mot acquired. It means, you can acquire a permit from one thread and release it from another thread using the same HazelcastInstance, but not different HazelcastInstances. In this mode, acquired permits are automatically released upon failure of the holder HazelcastInstance. So there is a minor behavioral difference to the Semaphore#release() method."
              },
              "initial-permits": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "Number of permits to initialize the Semaphore. If a positive value is set, the Semaphore is initialized with the given number of permits."
              }
            }
          },
          "description": "Configurations for CP Semaphore instances. The CP Semaphores can be configured with mappings under keys as their names."
        },
        "locks": {
          "type": "object",
          "description": "Configurations for FencedLock instances. The FencedLocks can be configured with mappings under keys as their names.",
          "additionalProperties": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "lock-acquire-limit": {
                "type": "integer",
                "default": 0,
                "minimum": 0,
                "description": " Maximum number of reentrant lock acquires. Once a caller acquires the lock this many times, it will not be able to acquire the lock again, until it makes at least one unlock() call. By default, no upper bound is set for the number of reentrant lock acquires, which means that once a caller acquires a FencedLock, all of its further lock() calls will succeed. However, for instance, if you set lock-acquire-limit to 2, once a caller acquires the lock, it will be able to acquire it once more, but its third lock() call will not succeed. If lock-acquire-limit is set to 1, then the lock becomes non-reentrant."
              }
            }
          }
        }
      }
    },
    "BackupCount": {
      "description": "Number of synchronous backups. For example, if 1 is set as the backup count, then all entries of the map will be copied to another JVM for fail-safety. 0 means no sync backup. The sum of backup-count and async-backup-count can't be larger than than 6.",
      "type": "integer",
      "minimum": 0,
      "default": 1,
      "maximum": 6
    },
    "AsyncBackupCount": {
      "description": "The number of asynchronous backups. 0 means no backups. The sum of backup-count and async-backup-count can't be larger than than 6.",
      "type": "integer",
      "minimum": 0,
      "default": 0,
      "maximum": 6
    },
    "List": {
      "type": "object",
      "description": "Name-value pairs of list configurations",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "statistics-enabled": {
            "type": "boolean",
            "default": true,
            "description": "When you enable it, you can retrieve list statistics."
          },
          "max-size": {
            "type": "integer",
            "default": 0,
            "description": "Maximum size of the list (item count). 0 means Integer.MAX_VALUE."
          },
          "backup-count": {
            "$ref": "#/definitions/BackupCount"
          },
          "async-backup-count": {
            "$ref": "#/definitions/AsyncBackupCount"
          },
          "item-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/ItemListener"
            }
          },
          "split-brain-protection-ref": {
            "type": "string",
            "description": "Adds the Split Brain Protection for this data-structure. You should set this value as a \"split-brain-protection\"'s name."
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "LdapSearchScope": {
      "enum": [
        "object",
        "one-level",
        "subtree"
      ],
      "default": "subtree"
    },
    "Security": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Set to true to enable Hazelcast's security features."
        },
        "realms": {
          "type": "array",
          "description": "Defines set of named security realms. Security realms are named security configurations which can be referenced from Hazelcast security configuration. Currently, the realms support configuring \"authentication\", and/or \"identity\". Only one type of authentication configuration and one type of identity configuration is allowed per the realm.",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "name": {
                "type": "string"
              },
              "authentication": {
                "type": "object",
                "propertyNames": {
                  "enum": [
                    "jaas",
                    "tls",
                    "ldap"
                  ]
                },
                "maxProperties": 1,
                "minProperties": 1,
                "properties": {
                  "jaas": {
                    "type": "array",
                    "description": "Defines JAAS authentication - i.e. list of login-module descriptions and optional \"properties\"",
                    "items": {
                      "type": "object",
                      "additionalProperties": false,
                      "properties": {
                        "class-name": {
                          "type": "string"
                        },
                        "usage": {
                          "enum": [
                            "REQUIRED",
                            "REQUISITE",
                            "SUFFICIENT",
                            "OPTIONAL"
                          ],
                          "default": "REQUIRED"
                        },
                        "properties": {
                          "type": "object"
                        }
                      },
                      "required": [
                        "class-name"
                      ]
                    }
                  },
                  "tls": {
                    "type": "object",
                    "additionalProperties": false,
                    "description": "TLS defines X.509 based authentication (for cases when SSL mutual authentication is configured in Hazelcast network configuration)",
                    "properties": {
                      "roleAttribute": {
                        "type": "string"
                      }
                    }
                  },
                  "ldap": {
                    "type": "object",
                    "additionalProperties": false,
                    "properties": {
                      "url": {
                        "type": "string"
                      },
                      "socket-factory-class-name": {
                        "type": "string"
                      },
                      "parse-dn": {
                        "type": "boolean"
                      },
                      "role-context": {
                        "type": "string"
                      },
                      "role-filter": {
                        "type": "string"
                      },
                      "role-mapping-attribute": {
                        "type": "string"
                      },
                      "role-mapping-mode": {
                        "enum": [
                          "attribute",
                          "reverse",
                          "direct"
                        ],
                        "default": "reverse"
                      },
                      "role-name-attribute": {
                        "type": "string"
                      },
                      "role-recursion-max-depth": {
                        "type": "integer",
                        "minimum": 0
                      },
                      "role-search-scope": {
                        "$ref": "#/definitions/LdapSearchScope"
                      },
                      "user-name-attribute": {
                        "type": "string"
                      },
                      "system-user-dn": {
                        "type": "string"
                      },
                      "system-user-password": {
                        "type": "string"
                      },
                      "password-attribute": {
                        "type": "string"
                      },
                      "user-context": {
                        "type": "string"
                      },
                      "user-filter": {
                        "type": "string"
                      },
                      "user-search-scope": {
                        "$ref": "#/definitions/LdapSearchScope"
                      }
                    }
                  }
                }
              },
              "identity": {
                "type": "object",
                "propertyNames": {
                  "enum": [
                    "username-password",
                    "kerberos",
                    "token",
                    "credentials-factory"
                  ]
                },
                "minProperties": 1,
                "maxProperties": 1,
                "properties": {
                  "username-password": {
                    "type": "object",
                    "additionalProperties": false,
                    "description": "Defines a static UsernamePasswordCredentials instance as the member's identity. It has mandatory \"username\" and \"password\" attributes.",
                    "properties": {
                      "username": {
                        "type": "string"
                      },
                      "password": {
                        "type": "string"
                      }
                    },
                    "required": [
                      "username",
                      "password"
                    ]
                  },
                  "token": {
                    "type": "object",
                    "additionalProperties": false,
                    "description": "Defines a static TokenCredentials instance as the client's identity. It has a \"value\" and it can have also \"encoding\" defined.",
                    "properties": {
                      "encoding": {
                        "enum": [
                          "none",
                          "base64"
                        ]
                      },
                      "value": {
                        "type": "string"
                      }
                    },
                    "required": [
                      "encoding",
                      "value"
                    ]
                  },
                  "credentials-factory": {
                    "description": " Specifies the name and properties of your class that you developed by implementing Hazelcast's Credentials interface. This element has a mandatory \"class-name\" attribute where you should define the factory class implementing ICredentialsFactory used to create Credentials objects. With the \"properties\" child property, you can define properties for the factory class.",
                    "$ref": "#/definitions/ClassNameWithProps"
                  }
                }
              }
            }
          }
        },
        "member-authentication": {
          "type": "object",
          "additionalProperties": false,
          "description": "Maps member authentication to a realm name.",
          "properties": {
            "realm": {
              "type": "string"
            }
          },
          "required": [
            "realm"
          ]
        },
        "client-authentication": {
          "type": "object",
          "additionalProperties": false,
          "description": "Maps client authentication to a realm name.",
          "properties": {
            "realm": {
              "type": "string"
            }
          },
          "required": [
            "realm"
          ]
        },
        "client-permission-policy": {
          "description": "Specifies the name and properties of your class that you developed by implementing Hazelcast's IPermissionPolicy interface, which is the default permission policy (com.hazelcast.security.IPermissionPolicy). This policy defines the client authorization specifications.",
          "$ref": "#/definitions/ClassNameWithProps"
        },
        "security-interceptors": {
          "description": "Specifies the security interceptor class that you developed by implementing Hazelcast's SecurityInterceptor interface to intercept every remote operation executed by a client.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "client-block-unmapped-actions": {
          "type": "boolean",
          "default": true,
          "description": "Specifies whether to block (true) or allow (false) actions, submitted as tasks in an Executor from the clients and have no permission mappings."
        },
        "client-permissions": {
          "description": "Lists the client permissions that can be accessed by the client permission policy. For each permission, you need to provide the end points and actions to be permitted. Also, the name and principal for each permission should be given using the \"name\" and \"principal\" attributes. Please see http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#permissions for all permissions and actions.",
          "type": "object",
          "propertyNames": {
            "enum": [
              "on-join-operation",
              "all",
              "config",
              "transaction",
              "map",
              "queue",
              "topic",
              "multimap",
              "list",
              "set",
              "flake-id-generator",
              "lock",
              "atomic-long",
              "countdown-latch",
              "semaphore",
              "executor-service",
              "durable-executor-service",
              "cardinality-estimator",
              "scheduled-executor",
              "cache",
              "user-code-deployment",
              "pn-counter"
            ]
          },
          "properties": {
            "on-join-operation": {
              "enum": [
                "RECEIVE",
                "SEND",
                "NONE"
              ]
            },
            "all": {
              "$ref": "#/definitions/SecurityPermission"
            },
            "config": {
              "$ref": "#/definitions/SecurityPermission"
            },
            "transaction": {
              "$ref": "#/definitions/SecurityPermission"
            },
            "sql": {
              "$ref": "#/definitions/SecurityPermission"
            }
          },
          "additionalProperties": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/SecurityPermission"
            }
          }
        }
      }
    },
    "SecurityPermission": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "principal": {
          "type": "string"
        },
        "endpoints": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "actions": {
          "anyOf": [
            {
              "type": "array",
              "items": {
                "$ref": "#/definitions/SecurityPermissionAction"
              }
            },
            {
              "type": "object",
              "patternProperties": {
                ".*": {
                  "$ref": "#/definitions/SecurityPermissionAction"
                }
              }
            }
          ]
        }
      }
    },
    "SecurityPermissionAction": {
      "enum": [
        "all",
        "create",
        "destroy",
        "put",
        "read",
        "remove",
        "lock",
        "intercept",
        "index",
        "listen",
        "publish",
        "modify",
        "acquire",
        "release",
        "deploy"
      ]
    },
    "NativeMemory": {
      "description": "This feature is available only in Hazelcast Enterprise HD.",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "Set as true to enable the High-Density Memory Store usage."
        },
        "allocator-type": {
          "enum": [
            "STANDARD",
            "POOLED"
          ],
          "default": "POOLED",
          "description": "Type of the memory allocator. The default value is POOLED. Available values are as follows: \\n- STANDARD: Allocates/frees the memory using default OS memory manager, \\n- POOLED: Manages memory blocks in thread local pools"
        },
        "size": {
          "type": "object",
          "properties": {
            "unit": {
              "enum": [
                "BYTES",
                "KILOBYTES",
                "MEGABYTES",
                "GIGABYTES"
              ],
              "default": "MEGABYTES",
              "description": "Unit can be bytes, kilobytes, megabytes and gigabytes. Default unit is MEGABYTES."
            },
            "value": {
              "type": "number",
              "default": 128,
              "minimum": 1,
              "description": "Default value is 128."
            }
          }
        },
        "min-block-size": {
          "type": "integer",
          "default": 16,
          "minimum": 1,
          "enum": [
            1,
            2,
            4,
            6,
            8,
            16,
            32,
            64,
            128,
            256,
            512,
            1024,
            2048,
            4096,
            8192,
            16384,
            32768,
            65536
          ],
          "description": "Minimum size of the blocks in bytes to split and fragment a page block to assign to an allocation request.\\n It is used only by the POOLED memory allocator. The value has to be power of two. Default value is 16."
        },
        "page-size": {
          "type": "integer",
          "default": 4194304,
          "minimum": 1,
          "description": "Size of the page in bytes to allocate memory as a block. \\n It is used only by the POOLED memory allocator. Its default value is 1 << 22 (about 4 MB)"
        },
        "metadata-space-percentage": {
          "type": "number",
          "default": 12.5,
          "minimum": 1,
          "description": "Percentage of the allocated native memory that is used for the metadata such as indexes, offsets, etc. \\n It is used only by the POOLED memory allocator. Its default value is 12.5."
        },
        "persistent-memory-directory": {
          "type": "string",
          "description": "Specifies the directory where the non-volatile memory (e.g. Intel Optane) is mounted. \\n If this element is not defined, the RAM is used as a native memory. \\n This directory will be created automatically if it does not exist.\\n To avoid collisions, every member of the cluster will create its own subfolder to work with the non-volatile memory."
        }
      }
    }
  },
  "TODO": false
}

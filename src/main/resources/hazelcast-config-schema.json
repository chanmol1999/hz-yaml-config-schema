{
  "$schema": "http://json-schema.org/draft-06/schema",
  "type": "object",
  "properties": {
    "hazelcast": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "import": {
          "$ref": "#/definitions/Import"
        },
        "config-replacers": {
          "$ref": "#/definitions/ConfigReplacers"
        },
        "cluster-name": {
          "type": "string"
        },
        "license-key": {
          "type": "string"
        },
        "instance-name": {
          "type": "string"
        },
        "management-center": {
          "$ref": "#/definitions/ManagementCenter"
        },
        "properties": {
          "type": "object"
        },
        "wan-replication": {
          "$ref": "#/definitions/WanReplication"
        },
        "network": {
          "$ref": "#/TODO"
        },
        "partition-group": {
          "$ref": "#/definitions/PartitionGroup"
        },
        "executor-service": {
          "$ref": "#/definitions/ExecutorService"
        },
        "durable-executor-service": {
          "$ref": "#/definitions/DurableExecutorService"
        },
        "scheduled-executor-service": {
          "$ref": "#/definitions/ScheduledExecutorService"
        },
        "cardinality-estimator": {
          "$ref": "#/definitions/CardinalityEstimator"
        },
        "queue": {
          "$ref": "#/definitions/Queue"
        },
        "map": {
          "$ref": "#/definitions/Map"
        },
        "multimap": {
          "$ref": "#/definitions/Multimap"
        },
        "replicatedmap": {
          "$ref": "#/definitions/ReplicatedMap"
        },
        "cache": {
          "$ref": "#/TODO"
        },
        "list": {
          "$ref": "#/TODO"
        },
        "set": {
          "$ref": "#/TODO"
        },
        "topic": {
          "$ref": "#/TODO"
        },
        "reliable-topic": {
          "$ref": "#/TODO"
        },
        "ringbuffer": {
          "$ref": "#/TODO"
        },
        "flake-id-generator": {
          "$ref": "#/TODO"
        },
        "listeners": {
          "$ref": "#/TODO"
        },
        "serialization": {
          "$ref": "#/TODO"
        },
        "native-memory": {
          "$ref": "#/TODO"
        },
        "security": {
          "$ref": "#/TODO"
        },
        "member-attributes": {
          "$ref": "#/TODO"
        },
        "split-brain-protection": {
          "$ref": "#/TODO"
        },
        "lite-member": {
          "$ref": "#/definitions/LiteMember"
        },
        "hot-restart-persistence": {
          "$ref": "#/TODO"
        },
        "user-code-deployment": {
          "$ref": "#/TODO"
        },
        "crdt-replication": {
          "$ref": "#/TODO"
        },
        "pn-counter": {
          "$ref": "#/TODO"
        },
        "advanced-network": {
          "$ref": "#/TODO"
        },
        "cp-subsystem": {
          "$ref": "#/TODO"
        },
        "metrics": {
          "$ref": "#/TODO"
        }
      }
    }
  },
  "definitions": {
    "Import": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "ConfigReplacers": {
      "type": "object",
      "properties": {
        "fail-if-value-missing": {
          "type": "boolean",
          "default": false
        },
        "replacers": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "class-name": {
                "type": "string"
              },
              "properties": {
                "type": "object"
              }
            },
            "required": [
              "class-name"
            ]
          }
        }
      }
    },
    "ManagementCenter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "scripting-enabled": {
          "type": "boolean",
          "default": false
        },
        "trusted-interfaces": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "WanReplication": false,
    "PartitionGroup": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false
        },
        "group-type": {
          "enum": [
            "HOST_AWARE",
            "CUSTOM",
            "PER_MEMBER",
            "ZONE_AWARE",
            "SPI"
          ],
          "default": "PER_MEMBER"
        },
        "member-group": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ExecutorService": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "statistics-enabled": {
            "type": "boolean",
            "default": true
          },
          "pool-size": {
            "$ref": "#/definitions/executorServicePoolSize"
          },
          "queue-capacity": {
            "type": "integer",
            "minimum": 1,
            "default": 2147483647
          },
          "split-brain-protection-ref": {
            "type": "string"
          }
        }
      }
    },
    "DurableExecutorService": {
      "type": "object",
      "additionalProperties": {
        "pool-size": {
          "$ref": "#/definitions/executorServicePoolSize"
        },
        "durability": {
          "type": "integer",
          "minimum": 0,
          "default": 1
        },
        "capacity": {
          "type": "integer",
          "minimum": 1,
          "default": 100
        },
        "split-brain-protection-ref": {
          "type": "string"
        }
      }
    },
    "ScheduledExecutorService": {
      "type": "object",
      "additionalProperties": {
        "pool-size": {
          "$ref": "#/definitions/executorServicePoolSize"
        },
        "durability": {
          "type": "integer",
          "minimum": 0,
          "default": 1
        },
        "capacity": {
          "type": "integer",
          "minimum": 1,
          "default": 100
        },
        "capacity-policy": {
          "enum": [
            "PER_NODE",
            "PER_PARTITION"
          ]
        },
        "split-brain-protection-ref": {
          "type": "string"
        },
        "merge-policy": {
          "$ref": "#/definitions/MergePolicy"
        }
      }
    },
    "executorServicePoolSize": {
      "type": "integer",
      "minimum": 1,
      "default": 16
    },
    "MergePolicyClassName": {
      "enum": [
        "ExpirationTimeMergePolicy",
        "HyperLogLogMergePolicy",
        "HigherHitsMergePolicy",
        "PutIfAbsentMergePolicy",
        "DiscardMergePolicy",
        "LatestUpdateMergePolicy",
        "PassThroughMergePolicy",
        "LatestAccessMergePolicy"
      ],
      "default": "PutIfAbsentMergePolicy"
    },
    "MergePolicy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "batch-size": {
          "type": "integer",
          "minimum": 0,
          "default": 100
        },
        "class-name": {
          "$ref": "#/definitions/MergePolicyClassName"
        }
      }
    },
    "CardinalityEstimator": {
      "additionalProperties": {
      }
    },
    "InMemoryFormat": {
      "enum": [
        "BINARY",
        "OBJECT",
        "NATIVE"
      ],
      "default": "BINARY",
      "description": "Binary type that will be used for storing records. Possible values: BINARY (default): keys and values will be stored as binary data. OBJECT: values will be stored in their object forms. NATIVE: values will be stored in non-heap region of JVM (Hazelcast Enterprise only)"
    },
    "Eviction": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "eviction-policy": {
          "enum": [
            "LRU",
            "LFU",
            "NONE",
            "RANDOM"
          ],
          "default": "NONE"
        },
        "max-size-policy": {
          "enum": [
            "PER_NODE",
            "PER_PARTITION",
            "USED_HEAP_PERCENTAGE",
            "USED_HEAP_SIZE",
            "FREE_HEAP_PERCENTAGE",
            "FREE_HEAP_SIZE",
            "ENTRY_COUNT",
            "USED_NATIVE_MEMORY_SIZE",
            "USED_NATIVE_MEMORY_PERCENTAGE",
            "FREE_NATIVE_MEMORY_SIZE",
            "FREE_NATIVE_MEMORY_PERCENTAGE"
          ],
          "default": "PER_NODE"
        },
        "size": {
          "type": "integer",
          "minimum": 0,
          "default": 2147483647
        }
      }
    },
    "IndexConfig": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "enum": [
            "SORTED",
            "BITMAP",
            "HASH"
          ],
          "default": "SORTED"
        },
        "name": {
          "type": "string"
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1
        },
        "bitmap-index-options": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "unique-key": {
              "type": "string",
              "default": "__key"
            },
            "unique-key-transformation": {
              "enum": [
                "OBJECT",
                "LONG",
                "RAW"
              ],
              "default": "OBJECT",
              "description": "Defines an assortment of transformations which can be applied to unique-key values. OBJECT: Extracted unique key value is interpreted as an object value. Non-negative unique ID is assigned to every distinct object value. LONG: Extracted unique key value is interpreted as a whole integer value of byte, short, int or long type. The extracted value is upcasted to long (if necessary) and unique non-negative ID is assigned to every distinct value. RAW: Extracted unique key value is interpreted as a whole integer value of byte, short, int or long type. The extracted value is upcasted to long (if necessary) and the resulting value is used directly as an ID."
            }
          }
        }
      },
      "required": [
        "attributes"
      ]
    },
    "Map": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "in-memory-format": {
            "$ref": "#/definitions/InMemoryFormat"
          },
          "metadata-policy": {
            "enum": [
              "CREATE_ON_UPDATE",
              "OFF"
            ],
            "default": "OFF"
          },
          "statistics-enabled": {
            "type": "boolean",
            "default": true
          },
          "cache-deserialized-values": {
            "enum": [
              "INDEX_ONLY",
              "NEVER",
              "ALWAYS"
            ],
            "default": "INDEX_ONLY"
          },
          "backup-count": {
            "description": "Number of synchronous backups. For example, if 1 is set as the backup count, then all entries of the map will be copied to another JVM for fail-safety. 0 means no sync backup.",
            "type": "integer",
            "minimum": 0,
            "default": 1
          },
          "async-backup-count": {
            "description": "The number of asynchronous backups. 0 means no backups.",
            "type": "integer",
            "minimum": 0,
            "default": 0
          },
          "time-to-live-seconds": {
            "description": "The maximum number of seconds for each entry to stay in the map.",
            "type": "integer",
            "minimum": 0,
            "default": 0
          },
          "max-idle-seconds": {
            "type": "integer",
            "minimum": 0,
            "default": 0
          },
          "eviction": {
            "$ref": "#/definitions/Eviction"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          },
          "read-backup-data": {
            "description": "Sets if read-backup-data (reading local backup entries) is enabled for this map.",
            "type": "boolean",
            "default": false
          },
          "hot-restart": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "description": "Sets whether hot restart is enabled on related data structure.",
                "type": "boolean",
                "default": false
              },
              "fsync": {
                "description": "Sets whether disk write should be followed by an fsync() system call.",
                "type": "boolean",
                "default": false
              }
            }
          },
          "event-journal": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "capacity": {
                "type": "integer",
                "minimum": 1,
                "default": 10000,
                "description": "The capacity is the total number of items that the event journal can hold at any moment. The actual number of items contained in the journal can be lower. NOTE: The capacity is shared equally between all partitions. This is done by assigning each partition {capacity / partitionCount} available slots in the event journal. Because of this, the effective total capacity may be somewhat lower and you must make sure that the configured capacity is at least greater than the partition count."
              },
              "time-to-live-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "Time to live is the time the event journal retains items before removing them from the journal. The events are removed on journal read and write actions, not while the journal is idle. Time to live can be disabled by setting timeToLiveSeconds to 0. This means that the events never expire but they can be overwritten when the capacity of the journal is exceeded."
              }
            }
          },
          "merkle-tree": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "depth": {
                "type": "integer",
                "minimum": 2,
                "maximum": 27,
                "default": 10
              }
            }
          },
          "map-store": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": true
              },
              "initial-mode": {
                "enum": [
                  "LAZY",
                  "EAGER"
                ],
                "default": "LAZY",
                "description": "LAZY: Default load mode where load is async; EAGER: load mode where load is blocked till all partitions are loaded."
              },
              "write-delay-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "The number of seconds to delay before writing (storing) the dirty records."
              },
              "write-batch-size": {
                "type": "integer",
                "minimum": 1,
                "default": 1,
                "description": "The number of operations to be included in each batch processing round."
              },
              "write-coalescing": {
                "type": "boolean",
                "default": true,
                "description": " Setting writeCoalescing is meaningful if you are using write-behind MapStore. When writeCoalescing is true, only the latest store operation on a key in the writeDelaySeconds time-window will be reflected to MapStore."
              },
              "class-name": {
                "type": "string",
                "description": "The name for the MapStore implementation class"
              },
              "factory-class-name": {
                "type": "string",
                "description": "The name for the MapStoreFactory implementation class"
              },
              "properties": {
                "type": "object",
                "default": {}
              }
            },
            "default": {
              "enabled": false
            }
          },
          "near-cache": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "time-to-live-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "The maximum number of seconds for each entry to stay in the Near Cache (time to live). Entries that are older than timeToLiveSeconds will automatically be evicted from the Near Cache."
              },
              "max-idle-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "The maximum number of seconds each entry can stay in the Near Cache as untouched (not-read). Entries that are not read (touched) more than maxIdleSeconds value will get removed from the Near Cache. Accepts any integer between 0 and Integer#MAX_VALUE. The value 0 means Integer#MAX_VALUE. The default is 0."
              },
              "invalidate-on-change": {
                "type": "boolean",
                "default": true,
                "description": "Sets if Near Cache entries are invalidated when the entries in the backing data structure are changed. When this setting is enabled, a Hazelcast instance with a Near Cache listens for cluster-wide changes on the entries of the backing data structure and invalidates its corresponding Near Cache entries. Changes done on the local Hazelcast instance always invalidate the Near Cache immediately."
              },
              "in-memory-format": {
                "$ref": "#/definitions/InMemoryFormat"
              },
              "cache-local-entries": {
                "type": "boolean",
                "default": false,
                "description": "Sets if local entries are also cached in the Near Cache. This is useful when the in-memory format of the Near Cache is different from the backing data structure. This setting has no meaning on Hazelcast clients, since they have no local entries."
              },
              "eviction": {
                "$ref": "#/definitions/Eviction"
              }
            }
          },
          "wan-replication-ref": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "merge-policy-class-name": {
                  "$ref": "#/definitions/MergePolicyClassName"
                },
                "republishing-enabled": {
                  "type": "boolean",
                  "default": true,
                  "description": "Sets if incoming WAN events to this member should be republished (forwarded) to this WAN replication reference."
                },
                "filters": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of class names implementing the CacheWanEventFilter or MapWanEventFilter for filtering outbound WAN replication events. NOTE: EE only"
                }
              }
            }
          },
          "indexes": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/IndexConfig"
            }
          },
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "extractor-class-name": {
                  "type": "string",
                  "description": "Fully qualified class name of the extractor used to extract the value of the attribute."
                }
              },
              "required": [
                "extractor-class-name"
              ],
              "description": "Contains the configuration of a custom attribute that will be extracted from a Map's entry using a given ValueExtractor."
            }
          },
          "entry-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EntryListener"
            },
            "description": "Adds listeners (listener classes) for the map entries using the \"entry-listener\" sub-elements"
          },
          "partition-lost-listeners": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "query-caches": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "include-value": {
                  "type": "boolean",
                  "default": true,
                  "description": "Enables value caching."
                },
                "predicate": {
                  "type": "object",
                  "additionalProperties": false,
                  "properties": {
                    "class-name": {
                      "type": "string"
                    }
                  },
                  "description": "Predicate to filter events which will be applied to the query cache."
                },
                "entry-listeners": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/EntryListener"
                  }
                },
                "in-memory-format": {
                  "$ref": "#/definitions/InMemoryFormat"
                },
                "populate": {
                  "type": "boolean",
                  "default": true,
                  "description": "Flag to enable/disable initial population of the QueryCache."
                },
                "coalesce": {
                  "type": "boolean",
                  "default": false
                },
                "delay-seconds": {
                  "type": "integer",
                  "minimum": 0,
                  "default": 0,
                  "description": "Minimum time in seconds that an event waits in the member's buffer."
                },
                "batch-size": {
                  "type": "integer",
                  "minimum": 1,
                  "default": 1,
                  "description": "The batch size which will be used to determine number of events to be sent in a batch to QueryCache."
                },
                "buffer-size": {
                  "type": "integer",
                  "minimum": 1,
                  "default": 16,
                  "description": "Maximum number of events which can be stored in a buffer of partition."
                },
                "eviction": {
                  "$ref": "#/definitions/Eviction"
                },
                "indexes": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/IndexConfig"
                  }
                }
              }
            }
          }
        }
      }
    },
    "EntryListener": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "class-name": {
          "type": "string"
        },
        "include-value": {
          "type": "boolean",
          "default": false,
          "description": "True if you want the entry event to contain the item values."
        },
        "local": {
          "type": "boolean",
          "default": false,
          "description": "True if you want to listen to the entries on the local member."
        }
      },
      "required": [
        "class-name"
      ]
    },
    "Queue": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "statistics-enabled": {
            "type": "boolean",
            "default": true,
            "description": "When you enable it, you can retrieve queue statistics."
          },
          "max-size": {
            "type": "integer",
            "minimum": 0,
            "description": "Maximum size of the queue. When a JVM's local queue size reaches the maximum, all put/offer operations will be blocked until the queue size of the JVM goes below this maximum. Its default value is 0, meaning Integer.MAX_VALUE"
          },
          "backup-count": {
            "type": "integer",
            "default": 1,
            "minimum": 0,
            "description": "Number of synchronous backups. Queue is a non-partitioned data structure, so all entries of a Queue resides in one partition. When this parameter is '1', it means there will be 1 backup of that Queue in another member in the cluster. When it is '2', 2 members will have the backup. 0 means there will be no backups."
          },
          "async-backup-count": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Number of asynchronous backups."
          },
          "empty-queue-ttl": {
            "type": "integer",
            "default": -1,
            "description": "Used to purge unused or empty queues. If you define a value (time in seconds) for this element, then your queue will be destroyed if it stays empty or unused for that time."
          },
          "item-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/ItemListener"
            }
          },
          "queue-store": {
            "type": "object",
            "additionalProperties": false,
            "description": "Includes configuration elements and attributes for your queue store implementation. When you want to load/store the distributed queue items from/to a persistent datastore, first implement Hazelcast's QueueStore interface and then configure it using this element",
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": true
              },
              "class-name": {
                "description": "The fully qualified name of the QueueStore implementation you want to use",
                "type": "string"
              },
              "factory-class-name": {
                "description": "The fully qualified name of the QueueStoreFactory which will be created by Hazelcast to instantiate QueueStores.",
                "type": "string"
              },
              "properties": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "binary": {
                    "type": "boolean",
                    "default": false,
                    "description": "If you do not reach the queue store from an external application, you might prefer to insert the items in binary form. To do so, set this property to true and skip the deserialization step, which is a performance optimization."
                  },
                  "memory-limit": {
                    "type": "integer",
                    "default": 1000,
                    "description": "Number of items after which Hazelcast will store items only to datastore. For example, if the memory limit is 1000, then the 1001st item will be put only to datastore. This feature is useful when you want to avoid out-of-memory conditions. If you want to always use memory, you can set it to Integer.MAX_VALUE."
                  },
                  "bulk-load": {
                    "type": "integer",
                    "default": 250,
                    "description": "Size of the bulks loaded from QueueStore when the queue is initialized."
                  }
                }
              }
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "ItemListener": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "include-value": {
          "type": "boolean",
          "default": true,
          "description": "Set to true if you want the item event to contain the item values."
        },
        "class-name": {
          "type": "string"
        }
      },
      "required": [
        "class-name"
      ]
    },
    "Multimap": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "backup-count": {
            "type": "integer",
            "minimum": 0,
            "default": 1
          },
          "async-backup-count": {
            "type": "integer",
            "minimum": 0,
            "default": 0
          },
          "value-collection-type": {
            "enum": [
              "SET",
              "LIST"
            ]
          },
          "binary": {
            "type": "boolean",
            "default": true,
            "description": "The in-memory format being used for representing the multimap. If it is false, the OBJECT in-memory format will be used."
          },
          "entry-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EntryListener"
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "ReplicatedMap": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "in-memory-format": {
            "$ref": "#/definitions/InMemoryFormat"
          },
          "async-fillup": {
            "type": "boolean",
            "default": true,
            "description": "Specifies whether the replicated map is available for reads before the initial replication is completed. If false, no Exception will be thrown when the replicated map is not yet ready, but call is blocked until the initial replication is completed."
          },
          "statistics-enabled": {
            "type": "boolean",
            "default": true,
            "description": "When you enable it, you can retrieve replicated map entry statistics such as creation time, expiration time, number of hits, key, value, etc."
          },
          "entry-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EntryListener"
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "LiteMember": {
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false,
          "description": "When you want to use a Hazelcast member as a lite member, set this element's \"enabled\" attribute to true in that member's YAML configuration. Lite members do not store data, do not have partitions and are used mainly to execute tasks and register listeners."
        }
      }
    }
  },
  "TODO": false
}


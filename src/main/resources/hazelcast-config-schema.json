{
  "$schema": "http://json-schema.org/draft-06/schema",
  "type": "object",
  "properties": {
    "hazelcast": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "import": {
          "$ref": "#/definitions/Import"
        },
        "config-replacers": {
          "$ref": "#/definitions/ConfigReplacers"
        },
        "cluster-name": {
          "type": "string"
        },
        "license-key": {
          "type": "string"
        },
        "instance-name": {
          "type": "string"
        },
        "management-center": {
          "$ref": "#/definitions/ManagementCenter"
        },
        "properties": {
          "type": "object"
        },
        "wan-replication": {
          "$ref": "#/definitions/WanReplication"
        },
        "network": {
          "$ref": "#/TODO"
        },
        "partition-group": {
          "$ref": "#/definitions/PartitionGroup"
        },
        "executor-service": {
          "$ref": "#/definitions/ExecutorService"
        },
        "durable-executor-service": {
          "$ref": "#/definitions/DurableExecutorService"
        },
        "scheduled-executor-service": {
          "$ref": "#/definitions/ScheduledExecutorService"
        },
        "cardinality-estimator": {
          "$ref": "#/definitions/CardinalityEstimator"
        },
        "queue": {
          "$ref": "#/definitions/Queue"
        },
        "map": {
          "$ref": "#/definitions/Map"
        },
        "multimap": {
          "$ref": "#/definitions/Multimap"
        },
        "replicatedmap": {
          "$ref": "#/definitions/ReplicatedMap"
        },
        "cache": {
          "$ref": "#/definitions/Cache"
        },
        "list": {
          "$ref": "#/TODO"
        },
        "set": {
          "$ref": "#/TODO"
        },
        "topic": {
          "$ref": "#/TODO"
        },
        "reliable-topic": {
          "$ref": "#/TODO"
        },
        "ringbuffer": {
          "$ref": "#/TODO"
        },
        "flake-id-generator": {
          "$ref": "#/TODO"
        },
        "listeners": {
          "$ref": "#/TODO"
        },
        "serialization": {
          "$ref": "#/TODO"
        },
        "native-memory": {
          "$ref": "#/TODO"
        },
        "security": {
          "$ref": "#/TODO"
        },
        "member-attributes": {
          "$ref": "#/TODO"
        },
        "split-brain-protection": {
          "$ref": "#/TODO"
        },
        "lite-member": {
          "$ref": "#/definitions/LiteMember"
        },
        "hot-restart-persistence": {
          "$ref": "#/TODO"
        },
        "user-code-deployment": {
          "$ref": "#/TODO"
        },
        "crdt-replication": {
          "$ref": "#/TODO"
        },
        "pn-counter": {
          "$ref": "#/TODO"
        },
        "advanced-network": {
          "$ref": "#/TODO"
        },
        "cp-subsystem": {
          "$ref": "#/definitions/CPSubsystem"
        },
        "metrics": {
          "$ref": "#/definitions/Metrics"
        }
      }
    }
  },
  "definitions": {
    "Import": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "ConfigReplacers": {
      "type": "object",
      "properties": {
        "fail-if-value-missing": {
          "type": "boolean",
          "default": false
        },
        "replacers": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "class-name": {
                "type": "string"
              },
              "properties": {
                "type": "object"
              }
            },
            "required": [
              "class-name"
            ]
          }
        }
      }
    },
    "ManagementCenter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "scripting-enabled": {
          "type": "boolean",
          "default": false
        },
        "trusted-interfaces": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "WanReplication": false,
    "PartitionGroup": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false
        },
        "group-type": {
          "enum": [
            "HOST_AWARE",
            "CUSTOM",
            "PER_MEMBER",
            "ZONE_AWARE",
            "SPI"
          ],
          "default": "PER_MEMBER"
        },
        "member-group": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ExecutorService": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "statistics-enabled": {
            "type": "boolean",
            "default": true
          },
          "pool-size": {
            "$ref": "#/definitions/executorServicePoolSize"
          },
          "queue-capacity": {
            "type": "integer",
            "minimum": 0,
            "default": 2147483647
          },
          "split-brain-protection-ref": {
            "type": "string"
          }
        }
      }
    },
    "DurableExecutorService": {
      "type": "object",
      "additionalProperties": {
        "pool-size": {
          "$ref": "#/definitions/executorServicePoolSize"
        },
        "durability": {
          "type": "integer",
          "minimum": 0,
          "default": 1
        },
        "capacity": {
          "type": "integer",
          "minimum": 1,
          "default": 100
        },
        "split-brain-protection-ref": {
          "type": "string"
        }
      }
    },
    "ScheduledExecutorService": {
      "type": "object",
      "additionalProperties": {
        "pool-size": {
          "$ref": "#/definitions/executorServicePoolSize"
        },
        "durability": {
          "type": "integer",
          "minimum": 0,
          "default": 1
        },
        "capacity": {
          "type": "integer",
          "minimum": 1,
          "default": 100
        },
        "capacity-policy": {
          "enum": [
            "PER_NODE",
            "PER_PARTITION"
          ]
        },
        "split-brain-protection-ref": {
          "type": "string"
        },
        "merge-policy": {
          "$ref": "#/definitions/MergePolicy"
        }
      }
    },
    "executorServicePoolSize": {
      "type": "integer",
      "minimum": 1,
      "default": 16
    },
    "MergePolicyClassName": {
      "enum": [
        "ExpirationTimeMergePolicy",
        "HyperLogLogMergePolicy",
        "HigherHitsMergePolicy",
        "PutIfAbsentMergePolicy",
        "DiscardMergePolicy",
        "LatestUpdateMergePolicy",
        "PassThroughMergePolicy",
        "LatestAccessMergePolicy"
      ],
      "default": "PutIfAbsentMergePolicy"
    },
    "MergePolicy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "batch-size": {
          "type": "integer",
          "minimum": 0,
          "default": 100
        },
        "class-name": {
          "$ref": "#/definitions/MergePolicyClassName"
        }
      }
    },
    "CardinalityEstimator": {
      "additionalProperties": {
      }
    },
    "InMemoryFormat": {
      "enum": [
        "BINARY",
        "OBJECT",
        "NATIVE"
      ],
      "default": "BINARY",
      "description": "Binary type that will be used for storing records. Possible values: BINARY (default): keys and values will be stored as binary data. OBJECT: values will be stored in their object forms. NATIVE: values will be stored in non-heap region of JVM (Hazelcast Enterprise only)"
    },
    "Eviction": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "eviction-policy": {
          "enum": [
            "LRU",
            "LFU",
            "NONE",
            "RANDOM"
          ],
          "default": "NONE"
        },
        "max-size-policy": {
          "enum": [
            "PER_NODE",
            "PER_PARTITION",
            "USED_HEAP_PERCENTAGE",
            "USED_HEAP_SIZE",
            "FREE_HEAP_PERCENTAGE",
            "FREE_HEAP_SIZE",
            "ENTRY_COUNT",
            "USED_NATIVE_MEMORY_SIZE",
            "USED_NATIVE_MEMORY_PERCENTAGE",
            "FREE_NATIVE_MEMORY_SIZE",
            "FREE_NATIVE_MEMORY_PERCENTAGE"
          ],
          "default": "PER_NODE"
        },
        "size": {
          "type": "integer",
          "minimum": 0,
          "default": 2147483647
        }
      }
    },
    "IndexConfig": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "enum": [
            "SORTED",
            "BITMAP",
            "HASH"
          ],
          "default": "SORTED"
        },
        "name": {
          "type": "string"
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1
        },
        "bitmap-index-options": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "unique-key": {
              "type": "string",
              "default": "__key"
            },
            "unique-key-transformation": {
              "enum": [
                "OBJECT",
                "LONG",
                "RAW"
              ],
              "default": "OBJECT",
              "description": "Defines an assortment of transformations which can be applied to unique-key values. OBJECT: Extracted unique key value is interpreted as an object value. Non-negative unique ID is assigned to every distinct object value. LONG: Extracted unique key value is interpreted as a whole integer value of byte, short, int or long type. The extracted value is upcasted to long (if necessary) and unique non-negative ID is assigned to every distinct value. RAW: Extracted unique key value is interpreted as a whole integer value of byte, short, int or long type. The extracted value is upcasted to long (if necessary) and the resulting value is used directly as an ID."
            }
          }
        }
      },
      "required": [
        "attributes"
      ]
    },
    "Map": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "in-memory-format": {
            "$ref": "#/definitions/InMemoryFormat"
          },
          "metadata-policy": {
            "enum": [
              "CREATE_ON_UPDATE",
              "OFF"
            ],
            "default": "OFF"
          },
          "statistics-enabled": {
            "type": "boolean",
            "default": true
          },
          "cache-deserialized-values": {
            "enum": [
              "INDEX_ONLY",
              "NEVER",
              "ALWAYS"
            ],
            "default": "INDEX_ONLY"
          },
          "backup-count": {
            "description": "Number of synchronous backups. For example, if 1 is set as the backup count, then all entries of the map will be copied to another JVM for fail-safety. 0 means no sync backup.",
            "type": "integer",
            "minimum": 0,
            "default": 1
          },
          "async-backup-count": {
            "description": "The number of asynchronous backups. 0 means no backups.",
            "type": "integer",
            "minimum": 0,
            "default": 0
          },
          "time-to-live-seconds": {
            "description": "The maximum number of seconds for each entry to stay in the map.",
            "type": "integer",
            "minimum": 0,
            "default": 0
          },
          "max-idle-seconds": {
            "type": "integer",
            "minimum": 0,
            "default": 0
          },
          "eviction": {
            "$ref": "#/definitions/Eviction"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          },
          "read-backup-data": {
            "description": "Sets if read-backup-data (reading local backup entries) is enabled for this map.",
            "type": "boolean",
            "default": false
          },
          "hot-restart": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "description": "Sets whether hot restart is enabled on related data structure.",
                "type": "boolean",
                "default": false
              },
              "fsync": {
                "description": "Sets whether disk write should be followed by an fsync() system call.",
                "type": "boolean",
                "default": false
              }
            }
          },
          "event-journal": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "capacity": {
                "type": "integer",
                "minimum": 1,
                "default": 10000,
                "description": "The capacity is the total number of items that the event journal can hold at any moment. The actual number of items contained in the journal can be lower. NOTE: The capacity is shared equally between all partitions. This is done by assigning each partition {capacity / partitionCount} available slots in the event journal. Because of this, the effective total capacity may be somewhat lower and you must make sure that the configured capacity is at least greater than the partition count."
              },
              "time-to-live-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "Time to live is the time the event journal retains items before removing them from the journal. The events are removed on journal read and write actions, not while the journal is idle. Time to live can be disabled by setting timeToLiveSeconds to 0. This means that the events never expire but they can be overwritten when the capacity of the journal is exceeded."
              }
            }
          },
          "merkle-tree": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "depth": {
                "type": "integer",
                "minimum": 2,
                "maximum": 27,
                "default": 10
              }
            }
          },
          "map-store": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": true
              },
              "initial-mode": {
                "enum": [
                  "LAZY",
                  "EAGER"
                ],
                "default": "LAZY",
                "description": "LAZY: Default load mode where load is async; EAGER: load mode where load is blocked till all partitions are loaded."
              },
              "write-delay-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "The number of seconds to delay before writing (storing) the dirty records."
              },
              "write-batch-size": {
                "type": "integer",
                "minimum": 1,
                "default": 1,
                "description": "The number of operations to be included in each batch processing round."
              },
              "write-coalescing": {
                "type": "boolean",
                "default": true,
                "description": " Setting writeCoalescing is meaningful if you are using write-behind MapStore. When writeCoalescing is true, only the latest store operation on a key in the writeDelaySeconds time-window will be reflected to MapStore."
              },
              "class-name": {
                "type": "string",
                "description": "The name for the MapStore implementation class"
              },
              "factory-class-name": {
                "type": "string",
                "description": "The name for the MapStoreFactory implementation class"
              },
              "properties": {
                "type": "object",
                "default": {}
              }
            },
            "default": {
              "enabled": false
            }
          },
          "near-cache": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "time-to-live-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "The maximum number of seconds for each entry to stay in the Near Cache (time to live). Entries that are older than timeToLiveSeconds will automatically be evicted from the Near Cache."
              },
              "max-idle-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "The maximum number of seconds each entry can stay in the Near Cache as untouched (not-read). Entries that are not read (touched) more than maxIdleSeconds value will get removed from the Near Cache. Accepts any integer between 0 and Integer#MAX_VALUE. The value 0 means Integer#MAX_VALUE. The default is 0."
              },
              "invalidate-on-change": {
                "type": "boolean",
                "default": true,
                "description": "Sets if Near Cache entries are invalidated when the entries in the backing data structure are changed. When this setting is enabled, a Hazelcast instance with a Near Cache listens for cluster-wide changes on the entries of the backing data structure and invalidates its corresponding Near Cache entries. Changes done on the local Hazelcast instance always invalidate the Near Cache immediately."
              },
              "in-memory-format": {
                "$ref": "#/definitions/InMemoryFormat"
              },
              "cache-local-entries": {
                "type": "boolean",
                "default": false,
                "description": "Sets if local entries are also cached in the Near Cache. This is useful when the in-memory format of the Near Cache is different from the backing data structure. This setting has no meaning on Hazelcast clients, since they have no local entries."
              },
              "eviction": {
                "$ref": "#/definitions/Eviction"
              }
            }
          },
          "wan-replication-ref": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "merge-policy-class-name": {
                  "$ref": "#/definitions/MergePolicyClassName"
                },
                "republishing-enabled": {
                  "type": "boolean",
                  "default": true,
                  "description": "Sets if incoming WAN events to this member should be republished (forwarded) to this WAN replication reference."
                },
                "filters": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of class names implementing the CacheWanEventFilter or MapWanEventFilter for filtering outbound WAN replication events. NOTE: EE only"
                }
              }
            }
          },
          "indexes": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/IndexConfig"
            }
          },
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "extractor-class-name": {
                  "type": "string",
                  "description": "Fully qualified class name of the extractor used to extract the value of the attribute."
                }
              },
              "required": [
                "extractor-class-name"
              ],
              "description": "Contains the configuration of a custom attribute that will be extracted from a Map's entry using a given ValueExtractor."
            }
          },
          "entry-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EntryListener"
            },
            "description": "Adds listeners (listener classes) for the map entries using the \"entry-listener\" sub-elements"
          },
          "partition-lost-listeners": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "query-caches": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "include-value": {
                  "type": "boolean",
                  "default": true,
                  "description": "Enables value caching."
                },
                "predicate": {
                  "type": "object",
                  "additionalProperties": false,
                  "properties": {
                    "class-name": {
                      "type": "string"
                    }
                  },
                  "description": "Predicate to filter events which will be applied to the query cache."
                },
                "entry-listeners": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/EntryListener"
                  }
                },
                "in-memory-format": {
                  "$ref": "#/definitions/InMemoryFormat"
                },
                "populate": {
                  "type": "boolean",
                  "default": true,
                  "description": "Flag to enable/disable initial population of the QueryCache."
                },
                "coalesce": {
                  "type": "boolean",
                  "default": false
                },
                "delay-seconds": {
                  "type": "integer",
                  "minimum": 0,
                  "default": 0,
                  "description": "Minimum time in seconds that an event waits in the member's buffer."
                },
                "batch-size": {
                  "type": "integer",
                  "minimum": 1,
                  "default": 1,
                  "description": "The batch size which will be used to determine number of events to be sent in a batch to QueryCache."
                },
                "buffer-size": {
                  "type": "integer",
                  "minimum": 1,
                  "default": 16,
                  "description": "Maximum number of events which can be stored in a buffer of partition."
                },
                "eviction": {
                  "$ref": "#/definitions/Eviction"
                },
                "indexes": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/IndexConfig"
                  }
                }
              }
            }
          }
        }
      }
    },
    "EntryListener": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "class-name": {
          "type": "string"
        },
        "include-value": {
          "type": "boolean",
          "default": false,
          "description": "True if you want the entry event to contain the item values."
        },
        "local": {
          "type": "boolean",
          "default": false,
          "description": "True if you want to listen to the entries on the local member."
        }
      },
      "required": [
        "class-name"
      ]
    },
    "Queue": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "statistics-enabled": {
            "type": "boolean",
            "default": true,
            "description": "When you enable it, you can retrieve queue statistics."
          },
          "max-size": {
            "type": "integer",
            "minimum": 0,
            "description": "Maximum size of the queue. When a JVM's local queue size reaches the maximum, all put/offer operations will be blocked until the queue size of the JVM goes below this maximum. Its default value is 0, meaning Integer.MAX_VALUE"
          },
          "backup-count": {
            "type": "integer",
            "default": 1,
            "minimum": 0,
            "description": "Number of synchronous backups. Queue is a non-partitioned data structure, so all entries of a Queue resides in one partition. When this parameter is '1', it means there will be 1 backup of that Queue in another member in the cluster. When it is '2', 2 members will have the backup. 0 means there will be no backups."
          },
          "async-backup-count": {
            "type": "integer",
            "minimum": 0,
            "default": 0,
            "description": "Number of asynchronous backups."
          },
          "empty-queue-ttl": {
            "type": "integer",
            "default": -1,
            "description": "Used to purge unused or empty queues. If you define a value (time in seconds) for this element, then your queue will be destroyed if it stays empty or unused for that time."
          },
          "item-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/ItemListener"
            }
          },
          "queue-store": {
            "type": "object",
            "additionalProperties": false,
            "description": "Includes configuration elements and attributes for your queue store implementation. When you want to load/store the distributed queue items from/to a persistent datastore, first implement Hazelcast's QueueStore interface and then configure it using this element",
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": true
              },
              "class-name": {
                "description": "The fully qualified name of the QueueStore implementation you want to use",
                "type": "string"
              },
              "factory-class-name": {
                "description": "The fully qualified name of the QueueStoreFactory which will be created by Hazelcast to instantiate QueueStores.",
                "type": "string"
              },
              "properties": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "binary": {
                    "type": "boolean",
                    "default": false,
                    "description": "If you do not reach the queue store from an external application, you might prefer to insert the items in binary form. To do so, set this property to true and skip the deserialization step, which is a performance optimization."
                  },
                  "memory-limit": {
                    "type": "integer",
                    "default": 1000,
                    "description": "Number of items after which Hazelcast will store items only to datastore. For example, if the memory limit is 1000, then the 1001st item will be put only to datastore. This feature is useful when you want to avoid out-of-memory conditions. If you want to always use memory, you can set it to Integer.MAX_VALUE."
                  },
                  "bulk-load": {
                    "type": "integer",
                    "default": 250,
                    "description": "Size of the bulks loaded from QueueStore when the queue is initialized."
                  }
                }
              }
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "ItemListener": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "include-value": {
          "type": "boolean",
          "default": true,
          "description": "Set to true if you want the item event to contain the item values."
        },
        "class-name": {
          "type": "string"
        }
      },
      "required": [
        "class-name"
      ]
    },
    "Multimap": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "backup-count": {
            "type": "integer",
            "minimum": 0,
            "default": 1
          },
          "async-backup-count": {
            "type": "integer",
            "minimum": 0,
            "default": 0
          },
          "value-collection-type": {
            "enum": [
              "SET",
              "LIST"
            ]
          },
          "binary": {
            "type": "boolean",
            "default": true,
            "description": "The in-memory format being used for representing the multimap. If it is false, the OBJECT in-memory format will be used."
          },
          "entry-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EntryListener"
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "ReplicatedMap": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "in-memory-format": {
            "$ref": "#/definitions/InMemoryFormat",
            "default": "OBJECT"
          },
          "async-fillup": {
            "type": "boolean",
            "default": true,
            "description": "Specifies whether the replicated map is available for reads before the initial replication is completed. If false, no Exception will be thrown when the replicated map is not yet ready, but call is blocked until the initial replication is completed."
          },
          "statistics-enabled": {
            "type": "boolean",
            "default": true,
            "description": "When you enable it, you can retrieve replicated map entry statistics such as creation time, expiration time, number of hits, key, value, etc."
          },
          "entry-listeners": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/EntryListener"
            }
          },
          "split-brain-protection-ref": {
            "type": "string"
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          }
        }
      }
    },
    "Cache": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "key-type": {
            "$ref": "#/definitions/ClassNameObj"
          },
          "value-type": {
            "$ref": "#/definitions/ClassNameObj"
          },
          "statistics-enabled": {
            "type": "boolean",
            "default": false,
            "description": "When you enable it, you can retrieve cache entry statistics such as creation time, expiration time, number of hits, key, value, etc."
          },
          "management-enabled": {
            "type": "boolean",
            "default": false,
            "description": "If set to true, JMX beans are enabled and collected statistics are provided. It doesn't automatically enable statistics collection."
          },
          "read-through": {
            "type": "boolean",
            "default": false,
            "description": "If set to true, enables read-through behavior of the cache to an underlying configured javax.cache.integration.CacheLoader which is also known as lazy-loading."
          },
          "write-through": {
            "type": "boolean",
            "default": false,
            "description": "If set to true, enables write-through behavior of the cache to an underlying configured javax.cache.integration.CacheWriter which passes any changed value to the external backend resource."
          },
          "cache-loader-factory": {
            "description": "Fully qualified class name of the javax.cache.configuration.Factory implementation providing a javax.cache.integration.CacheLoader instance to the cache.",
            "$ref": "#/definitions/ClassNameObj"
          },
          "cache-loader": {
            "type": "string",
            "description": "Name of the cache loader class."
          },
          "cache-writer-factory": {
            "$ref": "#/definitions/ClassNameObj",
            "description": "Fully qualified class name of the javax.cache.configuration.Factory implementation providing a javax.cache.integration.CacheWriter instance to the cache."
          },
          "cache-writer": {
            "type": "string",
            "description": "Name of the cache writer class."
          },
          "expiry-policy-factory": {
            "$ref": "#/definitions/ClassNameObj",
            "description": "Fully qualified class name of the javax.cache.configuration.Factory implementation providing a javax.cache.expiry.ExpiryPolicy instance to the cache."
          },
          "cache-entry-listeners": {
            "type": "object",
            "properties": {
              "cache-entry-listener": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "old-value-required": {
                    "type": "boolean",
                    "default": false,
                    "description": "If set to true, previously assigned values for the affected keys will be sent to the javax.cache.event.CacheEntryListener implementation. Setting this attribute to true creates additional traffic."
                  },
                  "synchronous": {
                    "type": "boolean",
                    "default": false,
                    "description": "If set to true, the javax.cache.event.CacheEntryListener implementation will be called in a synchronous manner."
                  },
                  "cache-entry-listener-factory": {
                    "$ref": "#/definitions/ClassNameObj",
                    "description": "Fully qualified class name of the javax.cache.configuration.Factory implementation providing a javax.cache.event.CacheEntryListener instance."
                  },
                  "cache-entry-event-filter-factory": {
                    "$ref": "#/definitions/ClassNameObj",
                    "description": "Fully qualified class name of the javax.cache.configuration.Factory implementation providing a javax.cache.event.CacheEntryEventFilter instance."
                  }
                }
              }
            },
            "description": "List of cache entry listeners."
          },
          "in-memory-format": {
            "$ref": "#/definitions/InMemoryFormat",
            "default": "BINARY"
          },
          "backup-count": {
            "type": "integer",
            "default": 1,
            "minimum": 0,
            "maximum": 6,
            "description": "Number of synchronous backups. If it is 1, for example, then all entries of the cache are copied to one other instance as synchronous for fail-safety."
          },
          "async-backup-count": {
            "type": "integer",
            "default": 0,
            "minimum": 0,
            "maximum": 6,
            "description": "Number of asynchronous backups. For example, if it is 1, then all entries of the cache are copied to one other instance as asynchronous for fail-safety. The sum of \"backup-count\" and \"async-backup-count\" cannot be larger than 6"
          },
          "eviction": {
            "$ref": "#/definitions/Eviction"
          },
          "wan-replication-ref": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the WAN replication configuration"
              },
              "republishing-enabled": {
                "type": "boolean",
                "default": true,
                "description": "When enabled, an incoming event to a member is forwarded to target cluster of that member. "
              },
              "filters": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "Filters to intercept WAN replication events before they are placed to WAN event replication queues by providing a filtering API. Just implement Hazelcast's CacheWanEventFilter interface to create your filters."
              },
              "merge-policy-class-name": {
                "enum": [
                  "HigherHitsMergePolicy",
                  "PassThroughMergePolicy"
                ],
                "description": "Resolve conflicts that occurred when target cluster already has the replicated entry key."
              }
            }
          },
          "split-brain-protection-ref": {
            "type": "string",
            "description": "Adds the split brain protection for this cache. The value should be a \"split-brain-protection\"'s name."
          },
          "partition-lost-listeners": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Adds the partition lost listeners that you created by implementing Hazelcast's PartitionLostListener interface."
          },
          "merge-policy": {
            "$ref": "#/definitions/MergePolicy"
          },
          "hot-restart": {
            "type": "object",
            "additionalProperties": false,
            "description": "Used to enable Hazelcast's Hot Restart Persistence feature for the cache. It is available only in Hazelcast Enterprise HD. Set its \"enabled\" to true to enable the feature. By default, it is disabled.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "fsync": {
                "type": "boolean",
                "default": false,
                "description": "Set as true if the writing to disk should be followed by an fsync() system call."
              }
            }
          },
          "event-journal": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "enabled": {
                "type": "boolean",
                "default": false
              },
              "capacity": {
                "type": "integer",
                "minimum": 0,
                "default": 10000,
                "description": "The capacity of the event journal. The capacity is the total number of items that the event journal can hold at any moment. The actual number of items contained in the journal can be lower. The capacity is shared equally between all partitions. This is done by assigning each partition capacity / partitionCount available slots in the event journal. Because of this, the effective total capacity may be somewhat lower and you must take into account that the configured capacity is at least greater than the partition count."
              },
              "time-to-live-seconds": {
                "type": "integer",
                "minimum": 0,
                "default": 0,
                "description": "Sets the time to live in seconds. Time to live is the time the event journal retains items before removing them from the journal. The events are removed on journal read and write actions, not while the journal is idle. Time to live can be disabled by setting timeToLiveSeconds to 0. This means that the events never expire but they can be overwritten when the capacity of the journal is exceeed. Any integer between 0 and Integer.MAX_VALUE. 0 means infinite."
              }
            }
          },
          "disable-per-entry-invalidation-events": {
            "type": "boolean",
            "default": false,
            "description": "Disables invalidation events for each entry; but full-flush invalidation events are still enabled. Full-flush invalidation means the invalidation of events for all entries when clear is called."
          }
        }
      }
    },
    "ClassNameObj": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "class-name": {
          "type": "string",
          "description": "Fully qualified class name."
        }
      },
      "required": [
        "class-name"
      ]
    },
    "Metrics": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "The master-switch for the metrics collection. If this is set to false no metrics collection is done, regardless of the other settings."
        },
        "management-center": {
          "type": "object",
          "description": "Defines the Hazelcast Management Center related metrics configuration.",
          "additionalProperties": false,
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": true,
              "description": "Controls whether the metrics collected are exposed to Hazelcast Management Center. Please note that the metrics are polled by the Hazelcast Management Center, hence the members need to buffer the collected metrics between two polls. The aim for this switch is to reduce memory consumption of the metrics system if the Hazelcast Management Center is not used."
            },
            "retention-seconds": {
              "type": "integer",
              "minimum": 1,
              "default": 5,
              "description": "Sets the number of seconds the metrics will be retained on the instance. More retention means more heap memory, but allows for longer client hiccups without losing a value (for example to restart the Management Center)."
            }
          }
        },
        "jmx": {
          "type": "object",
          "description": "Defines the JMX related metrics configuration.",
          "additionalProperties": false,
          "properties": {
            "enabled": {
              "type": "boolean",
              "default": true,
              "description": "Controls whether the metrics collected are exposed to through JMX. It is enabled by default. In order to expose the metrics, the metrics system need to be enabled via the enabled master-switch attribute."
            }
          }
        },
        "collection-frequency-seconds": {
          "type": "integer",
          "minimum": 1,
          "default": 5,
          "description": "Sets the metrics collection frequency in seconds."
        }
      }
    },
    "LiteMember": {
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": false
        }
      },
      "description": "When you want to use a Hazelcast member as a lite member, set this element's \"enabled\" attribute to true in that member's YAML configuration. Lite members do not store data, do not have partitions and are used mainly to execute tasks and register listeners."
    },
    "CPSubsystem": {
      
    }
  },
  "TODO": false
}

